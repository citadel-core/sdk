import { ApiConnection } from "platform/connection.js";
import {
  Channel,
  PendingChannelsResponse_WaitingCloseChannel,
  PendingChannelsResponse_ForceClosedChannel,
  PendingChannelsResponse_PendingOpenChannel,
  EstimateFeeResponse,
  PendingChannelsResponse,
  ChannelFeeReport,
} from "../autogenerated-types";

export type Channel_extended = Channel & {
  type?: string;
};

export type WaitingCloseChannel_extended =
  PendingChannelsResponse_WaitingCloseChannel & {
    type?: string;
  };

export type PendingForceClosedChannel_extended =
  PendingChannelsResponse_ForceClosedChannel & {
    type?: string;
  };

export type PendingOpenChannel_extended =
  PendingChannelsResponse_PendingOpenChannel & {
    type?: string;
    initiator?: boolean;
  };

export type EstimateFeeResponseExtended = EstimateFeeResponse & {
  sweepAmount?: number;
};


export class LNDChannel extends ApiConnection {
  constructor(baseUrl: string) {
    super(`${baseUrl}${baseUrl.endsWith("/") ? "" : "/"}channel`);
  }

  public set jwt(newJwt: string) {
    this._jwt = newJwt;
  }

  public async list(): Promise<Channel_extended[]> {
    return (await this.get("")) as Channel_extended[];
  }

  public async estimateFee(
    amt: number | string,
    confTarget: number,
    sweep = false
  ): Promise<EstimateFeeResponseExtended> {
    if (confTarget <= 0)
      throw new TypeError("Confirmation target must be above 0");
    return (await this.get(
      `/estimateFee?amt=${amt}&confTarget=0&sweep=${sweep}`
    )) as EstimateFeeResponseExtended;
  }

  public async estimateFeeAll(
    amt: number | string,
    sweep = false
  ): Promise<{
    fast: EstimateFeeResponseExtended;
    slow: EstimateFeeResponseExtended;
    normal: EstimateFeeResponseExtended;
    cheapest: EstimateFeeResponseExtended;
  }> {
    return (await this.get(
      `/estimateFee?amt=${amt}&confTarget=0&sweep=${sweep}`
    )) as {
      fast: EstimateFeeResponseExtended;
      slow: EstimateFeeResponseExtended;
      normal: EstimateFeeResponseExtended;
      cheapest: EstimateFeeResponseExtended;
    };
  }

  public async getPendingChannels(): Promise<PendingChannelsResponse> {
    return (await this.get("/pending")) as PendingChannelsResponse;
  }

  public async getPolicy(): Promise<ChannelFeeReport[]> {
    return (await this.get("/policy")) as ChannelFeeReport[];
  }

  public async setPolicy(
    chanPoint: string,
    baseFeeMsat: number | string,
    feeRate: number,
    timeLockDelta = 144,
    global = false
  ): Promise<void> {
    this.post("/policy", {
      chanPoint,
      baseFeeMsat,
      feeRate,
      timeLockDelta,
      global,
    });
  }

  public async closeChannel(channelPoint: string, force = false): Promise<void> {
    this.post(`/close`, { channelPoint, force });
  }

  public async channelCount(): Promise<number> {
    return ((await this.get("/count")) as { count: number }).count;
  }

  /**
   * Open a new channel
   * 
   * @param pubKey The pubkey of the peer to open a channel with
   * @param ip The IP address of the peer to open a channel with
   * @param port The port of the peer to open a channel with
   * @param amt The amount to open the channel with
   * @param satPerByte The amount to pay per byte of the opening transaction
   * @returns The ID of the funding transaction
   */
  public async openChannel(
    pubKey: string,
    ip: string,
    port: number | string,
    amt: string | number,
    satPerByte: number | undefined
  ): Promise<string> {
    return ((await this.post("/openChannel", {
      pubKey,
      ip,
      port,
      amt,
      satPerByte,
    })) as { fundingTxId: string }).fundingTxId;
  }
}
